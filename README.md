# goit-algo-hw-09


Реалізовано дві функції `find_coins_greedy` та `find_min_coins` для пошуку кількості монет яких необхідно повернути для певної суми

Для функції `find_coins_greedy` використовувався ітеративний метод, який полягає у тому, що ми із поточної суми вираховуємо найбільш допустиме значення для монети, допоки сума не буде дорівнювати 0


Для функції `find_min_coins` використовувався метод динаміного програмування, який в даному випадку, запонює таблиці значень для кожної суми, а потім вираховує відповідну необхідну кількість монет


###  Тестування функцій
Вивід резлутьтатів при таких прамаетрах тестування:

- кількість тестів 100
- суми які необхідно знайти 113, 2757, 93232, 96273232


```
Testing algoritm Жадібний алгортим for input sum 113 ......

Result for algoritm Жадібний алгортим elapsed time:0.0001315000008617062
====================================================================================================
Testing algoritm Жадібний алгортим for input sum 2757 ......

Result for algoritm Жадібний алгортим elapsed time:0.0008841000017127953
====================================================================================================
Testing algoritm Жадібний алгортим for input sum 93232 ......

Result for algoritm Жадібний алгортим elapsed time:0.03196290000050794
====================================================================================================
Testing algoritm Жадібний алгортим for input sum 96273232 ......

Result for algoritm Жадібний алгортим elapsed time:32.71193190000122
====================================================================================================
Testing algoritm Динамічне програмування for input sum 113 ......

Result for algoritm Динамічне програмування elapsed time:0.00017139999908977188
====================================================================================================
Testing algoritm Динамічне програмування for input sum 2757 ......

Result for algoritm Динамічне програмування elapsed time:0.0011766999996325467
====================================================================================================
Testing algoritm Динамічне програмування for input sum 93232 ......

Result for algoritm Динамічне програмування elapsed time:0.03308169999945676
====================================================================================================
Testing algoritm Динамічне програмування for input sum 96273232 ......

Result for algoritm Динамічне програмування elapsed time:32.68744080000033
====================================================================================================
****************************************************************************************************
Result for 113 by greedy {50: 2, 10: 1, 2: 1, 1: 1}
Result for 113 by dynamic {50: 2, 10: 1, 2: 1, 1: 1}
****************************************************************************************************
Result for 2757 by greedy {50: 55, 5: 1, 2: 1}
Result for 2757 by dynamic {50: 55, 5: 1, 2: 1}
****************************************************************************************************
Result for 93232 by greedy {50: 1864, 25: 1, 5: 1, 2: 1}
Result for 93232 by dynamic {50: 1864, 25: 1, 5: 1, 2: 1}
****************************************************************************************************
Result for 96273232 by greedy {50: 1925464, 25: 1, 5: 1, 2: 1}
Result for 96273232 by dynamic {50: 1925464, 25: 1, 5: 1, 2: 1}
```

Як бачимо із результів обидва алгортми досить швидко працють з невеликими сумами,
проте при збільшенні суми, час для кожного із алгортмів зростає.

Враховуючи незначні показники швидкості роботи динамічного прогармування та скалдність його імплементації,
можемо зробити висновок, що в даноу випадку жадібний алгоритм кращий, тому що він інтуєтивно простіший та зрозуміліший.

Якщо ж для нас важливий час виконання та елегнтінсть результату, то звісно краще використувати динамічне прграмування.